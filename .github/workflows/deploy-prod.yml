name: Deploy to PROD

on:
  push:
    branches:
      - main
  workflow_dispatch:  # Allows manual trigger

env:
  AWS_REGION: us-east-1  # Update to your preferred region
  ENVIRONMENT: PROD
  STACK_NAME: chatbot-prod-infrastructure

jobs:
  deploy:
    name: Deploy Backend to PROD
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get Latest Amazon Linux 2023 AMI ID
        id: get-ami
        run: |
          AMI_ID=$(aws ec2 describe-images \
            --owners amazon \
            --filters "Name=name,Values=al2023-ami-*-x86_64" "Name=state,Values=available" \
            --query 'Images | sort_by(@, &CreationDate) | [-1].ImageId' \
            --region ${{ env.AWS_REGION }} \
            --output text)
          
          if [ -z "$AMI_ID" ] || [ "$AMI_ID" == "None" ]; then
            echo "âŒ Error: Could not find AMI. Trying alternative filter..."
            # Try alternative filter for Amazon Linux 2023
            AMI_ID=$(aws ec2 describe-images \
              --owners amazon \
              --filters "Name=name,Values=amzn2-ami-hvm-*-x86_64-gp2" "Name=state,Values=available" \
              --query 'Images | sort_by(@, &CreationDate) | [-1].ImageId' \
              --region ${{ env.AWS_REGION }} \
              --output text)
          fi
          
          if [ -z "$AMI_ID" ] || [ "$AMI_ID" == "None" ]; then
            echo "âŒ Error: Could not find any AMI"
            exit 1
          fi
          
          echo "AMI_ID=$AMI_ID" >> $GITHUB_OUTPUT
          echo "âœ… Found AMI: $AMI_ID"

      - name: Create or Update CloudFormation Stack
        id: cloudformation
        run: |
          # Check if stack exists
          if aws cloudformation describe-stacks --stack-name ${{ env.STACK_NAME }} --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
            echo "Stack exists, checking for updates..."
            UPDATE_OUTPUT=$(aws cloudformation update-stack \
              --stack-name ${{ env.STACK_NAME }} \
              --template-body file://infrastructure/cloudformation-template.yaml \
              --parameters ParameterKey=InstanceType,ParameterValue=t3.micro \
                           ParameterKey=KeyPairName,ParameterValue=${{ secrets.AWS_KEY_PAIR_NAME }} \
                           ParameterKey=Environment,ParameterValue=${{ env.ENVIRONMENT }} \
                           ParameterKey=AmiId,ParameterValue=${{ steps.get-ami.outputs.AMI_ID }} \
              --capabilities CAPABILITY_NAMED_IAM \
              --region ${{ env.AWS_REGION }} 2>&1) || UPDATE_EXIT_CODE=$?
            
            if [ "${UPDATE_EXIT_CODE:-0}" -eq 0 ]; then
              echo "Stack update initiated, waiting for completion..."
              aws cloudformation wait stack-update-complete \
                --stack-name ${{ env.STACK_NAME }} \
                --region ${{ env.AWS_REGION }}
              echo "âœ… Stack updated successfully"
            elif echo "$UPDATE_OUTPUT" | grep -q "No updates are to be performed"; then
              echo "â„¹ï¸  No stack updates needed (stack is already up to date)"
            else
              echo "âŒ Stack update failed:"
              echo "$UPDATE_OUTPUT"
              exit 1
            fi
          else
            echo "Stack does not exist, creating..."
            aws cloudformation create-stack \
              --stack-name ${{ env.STACK_NAME }} \
              --template-body file://infrastructure/cloudformation-template.yaml \
              --parameters ParameterKey=InstanceType,ParameterValue=t3.micro \
                           ParameterKey=KeyPairName,ParameterValue=${{ secrets.AWS_KEY_PAIR_NAME }} \
                           ParameterKey=Environment,ParameterValue=${{ env.ENVIRONMENT }} \
                           ParameterKey=AmiId,ParameterValue=${{ steps.get-ami.outputs.AMI_ID }} \
              --capabilities CAPABILITY_NAMED_IAM \
              --region ${{ env.AWS_REGION }}
            
            echo "Waiting for stack creation to complete..."
            aws cloudformation wait stack-create-complete \
              --stack-name ${{ env.STACK_NAME }} \
              --region ${{ env.AWS_REGION }}
            echo "âœ… Stack created successfully"
          fi

      - name: Get EC2 Instance IP
        id: get-instance-ip
        run: |
          INSTANCE_IP=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].Outputs[?OutputKey==`PublicIP`].OutputValue' \
            --output text)
          
          echo "INSTANCE_IP=$INSTANCE_IP" >> $GITHUB_OUTPUT
          echo "EC2 Instance IP: $INSTANCE_IP"

      - name: Store OpenAI API Key in SSM
        run: |
          aws ssm put-parameter \
            --name "/chatbot/prod/OPENAI_API_KEY" \
            --type "SecureString" \
            --value "${{ secrets.OPENAI_API_KEY }}" \
            --overwrite \
            --region ${{ env.AWS_REGION }}

      - name: Wait for EC2 Instance to be ready
        run: |
          INSTANCE_ID=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].Outputs[?OutputKey==`InstanceId`].OutputValue' \
            --output text)
          
          echo "Waiting for instance $INSTANCE_ID to be running..."
          aws ec2 wait instance-status-ok \
            --instance-ids $INSTANCE_ID \
            --region ${{ env.AWS_REGION }}
          
          echo "Instance is ready"
          
          # Additional wait for SSH to be available
          echo "Waiting for SSH to be available..."
          sleep 30

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.AWS_SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ steps.get-instance-ip.outputs.INSTANCE_IP }} >> ~/.ssh/known_hosts || true

      - name: Deploy application to EC2
        env:
          INSTANCE_IP: ${{ steps.get-instance-ip.outputs.INSTANCE_IP }}
        run: |
          # Copy deployment script
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            scripts/deploy.sh ec2-user@$INSTANCE_IP:/tmp/ || exit 1
          
          # Make deploy script executable on remote
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            ec2-user@$INSTANCE_IP "chmod +x /tmp/deploy.sh" || exit 1
          
          # Create tarball excluding unnecessary files
          echo "Creating deployment tarball..."
          tar --exclude='venv' \
              --exclude='__pycache__' \
              --exclude='*.pyc' \
              --exclude='.git' \
              --exclude='database/*.db' \
              --exclude='.env' \
              --exclude='*.log' \
              --exclude='.DS_Store' \
              --exclude='node_modules' \
              --exclude='.github' \
              -czf /tmp/chatbot-deploy.tar.gz .
          
          # Transfer tarball to EC2
          echo "Transferring files to EC2..."
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            /tmp/chatbot-deploy.tar.gz ec2-user@$INSTANCE_IP:/tmp/ || exit 1
          
          # Extract tarball on EC2 and clean up
          echo "Extracting files on EC2..."
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            ec2-user@$INSTANCE_IP "mkdir -p /opt/chatbot-service && cd /opt/chatbot-service && tar -xzf /tmp/chatbot-deploy.tar.gz && rm /tmp/chatbot-deploy.tar.gz" || exit 1
          
          # Clean up local tarball
          rm /tmp/chatbot-deploy.tar.gz
          
          # Execute deployment script
          echo "Running deployment script..."
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
            ec2-user@$INSTANCE_IP "bash /tmp/deploy.sh ${{ env.ENVIRONMENT }} ${{ env.AWS_REGION }}" || exit 1

      - name: Health Check
        run: |
          INSTANCE_IP=${{ steps.get-instance-ip.outputs.INSTANCE_IP }}
          echo "Waiting for service to start..."
          sleep 30
          
          for i in {1..10}; do
            if curl -f http://$INSTANCE_IP:8000/health; then
              echo "âœ… Service is healthy!"
              exit 0
            fi
            echo "Attempt $i failed, retrying in 10 seconds..."
            sleep 10
          done
          
          echo "âŒ Health check failed"
          exit 1

      - name: Deployment Summary
        run: |
          INSTANCE_IP=${{ steps.get-instance-ip.outputs.INSTANCE_IP }}
          echo "## ðŸš€ Deployment Complete!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ env.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
          echo "**Instance IP:** $INSTANCE_IP" >> $GITHUB_STEP_SUMMARY
          echo "**API URL:** http://$INSTANCE_IP:8000" >> $GITHUB_STEP_SUMMARY
          echo "**Health Check:** http://$INSTANCE_IP:8000/health" >> $GITHUB_STEP_SUMMARY
          echo "**API Docs:** http://$INSTANCE_IP:8000/docs" >> $GITHUB_STEP_SUMMARY

